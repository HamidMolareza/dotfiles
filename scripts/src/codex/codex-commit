#!/usr/bin/env python3
"""
codex-commit: Generate a Conventional Commit message for git changes.

Examples:
  codex-commit | clipboard
  codex-commit file1 file2 file3 | clipboard
  codex-commit *.md | clipboard
  codex-commit docs/ | clipboard
  codex-commit --staged src/foo.py | clipboard
  codex-commit --worktree docs/ | clipboard

STDOUT: commit message only
STDERR: errors (and optional verbose progress)
"""

from __future__ import annotations

import argparse
import glob
import json
import os
import re
import shutil
import subprocess
import sys
import textwrap
import tempfile
from dataclasses import dataclass
from pathlib import Path, PurePosixPath
from typing import Iterable


INSTRUCTION = r"""
Conventional Commits style
<type>(<scope>): <subject>

<body>

<breaking-changes-section>

<footer>

Type must be exactly one of:
feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

Scope:
- derive from file paths/modules if obvious (short, lowercase, no spaces)
- otherwise omit scope entirely: "<type>: <subject>"

Subject:
- imperative mood ("add", "fix", "update", "remove")
- <= 72 chars
- no trailing period

Body:
- only if non-trivial
- use short bullets or short paragraphs
- wrap ~72 chars where reasonable

Breaking changes:
- include only if truly breaking
- format exactly: "BREAKING CHANGE: ..."

Footer:
- include only if relevant
- If branch name contains an issue number like "feature/123-..." or "fix/456-...",
  add a footer like "Refs #123" (or "Closes #456" if clearly a fix).

Output format:
- Output only the commit message text, ready to paste into “git commit”.
- Do not add explanations, comments, extra text, or code fences.
""".strip()

# Default "noise" excludes (can be disabled via --no-default-excludes)
DEFAULT_EXCLUDE_GLOBS = [
    "**/package-lock.json",
    "**/yarn.lock",
    "**/pnpm-lock.yaml",
    "**/bun.lockb",
]

# Default "sensitive content" file globs: do not include patch content for these by default.
DEFAULT_SENSITIVE_GLOBS = [
    "**/.env",
    "**/.env.*",
    "**/*.pem",
    "**/*.key",
    "**/*.p12",
    "**/*.pfx",
    "**/id_rsa",
    "**/id_rsa.*",
    "**/id_ed25519",
    "**/id_ed25519.*",
]


@dataclass(frozen=True)
class FileChange:
    path: str               # repo-relative posix path
    kind: str               # "tracked" | "untracked"
    added: int | None       # None for binary/unknown
    deleted: int | None
    score: int              # used to pick most informative patches first


def run(cmd: list[str], cwd: str | None = None, check: bool = True) -> subprocess.CompletedProcess[str]:
    return subprocess.run(
        cmd,
        cwd=cwd,
        check=check,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )


def git(repo_root: str, args: list[str]) -> tuple[str, int]:
    p = run(["git", *args], cwd=repo_root, check=False)
    return p.stdout, p.returncode


def find_codex_bin() -> str:
    env = os.environ.get("CODEX_BIN")
    if env and shutil.which(env):
        return env
    for cand in ("codex1", "codex2"):
        if shutil.which(cand):
            return cand
    raise FileNotFoundError("Could not find Codex CLI. Install it and ensure `codex` is on PATH.")


def expand_file_args(raw_args: list[str]) -> list[str]:
    """Expand globs ourselves (helps if user quotes globs); harmless if shell already expanded."""
    out: list[str] = []
    for a in raw_args:
        if any(ch in a for ch in "*?[]") and not Path(a).exists():
            matches = glob.glob(a, recursive=True)
            out.extend(matches if matches else [a])
        else:
            out.append(a)
    return out


def to_repo_rel(repo_root: Path, p: str) -> str:
    """Convert a path to repo-relative POSIX path when possible."""
    path = Path(p)
    if not path.is_absolute():
        path = (Path.cwd() / path).resolve()
    try:
        rel = path.relative_to(repo_root.resolve())
        return rel.as_posix()
    except Exception:
        # If it's not a real filesystem path (e.g. git pathspec), keep as-is.
        return p


def normalize_pathspecs(repo_root: Path, raw_files: list[str]) -> list[str]:
    expanded = expand_file_args(raw_files)
    specs = [to_repo_rel(repo_root, f) for f in expanded]
    return [s for s in specs if s.strip()]


def matches_any_glob(path_posix: str, globs_: Iterable[str]) -> bool:
    p = PurePosixPath(path_posix)
    for g in globs_:
        try:
            if p.match(g):
                return True
        except Exception:
            # If a glob is weird, just ignore it.
            continue
    return False


def filter_untracked_by_specs(repo_root: str, specs: list[str]) -> list[str]:
    # Prefer git's pathspec filtering (works well for directories and files)
    args = ["ls-files", "--others", "--exclude-standard"]
    if specs:
        args += ["--", *specs]
    out, _ = git(repo_root, args)
    return [ln.strip() for ln in out.splitlines() if ln.strip()]


def parse_numstat(numstat_text: str) -> dict[str, tuple[int | None, int | None]]:
    """
    Parse `git diff --numstat` output:
      added<TAB>deleted<TAB>path
    Binary files can show '-' for added/deleted.
    """
    m: dict[str, tuple[int | None, int | None]] = {}
    for line in numstat_text.splitlines():
        parts = line.split("\t")
        if len(parts) < 3:
            continue
        a, d, path = parts[0], parts[1], parts[2]
        added = int(a) if a.isdigit() else None
        deleted = int(d) if d.isdigit() else None
        m[path.strip()] = (added, deleted)
    return m


def has_staged_diff(repo_root: str, specs: list[str]) -> bool:
    args = ["diff", "--cached", "--quiet"]
    if specs:
        args += ["--", *specs]
    p = run(["git", *args], cwd=repo_root, check=False)
    return p.returncode == 1


def redact_secrets(text: str) -> str:
    """
    Best-effort redaction. This does not guarantee catching all secrets,
    but it significantly reduces accidental leakage.
    """
    # Private key blocks
    text = re.sub(
        r"-----BEGIN [A-Z0-9 ]*PRIVATE KEY-----.*?-----END [A-Z0-9 ]*PRIVATE KEY-----",
        "-----BEGIN PRIVATE KEY-----\n<REDACTED>\n-----END PRIVATE KEY-----",
        text,
        flags=re.DOTALL,
    )

    # Common tokens/keys
    patterns = [
        (r"\bAKIA[0-9A-Z]{16}\b", "<REDACTED_AWS_ACCESS_KEY_ID>"),
        (r"\bASIA[0-9A-Z]{16}\b", "<REDACTED_AWS_TEMP_ACCESS_KEY_ID>"),
        (r"\bAIza[0-9A-Za-z\-_]{35}\b", "<REDACTED_GOOGLE_API_KEY>"),
        (r"\bghp_[A-Za-z0-9]{36}\b", "<REDACTED_GITHUB_TOKEN>"),
        (r"\bgithub_pat_[A-Za-z0-9_]{50,}\b", "<REDACTED_GITHUB_PAT>"),
        (r"\bxox[baprs]-[A-Za-z0-9-]{10,}\b", "<REDACTED_SLACK_TOKEN>"),
        (r"\bsk_live_[A-Za-z0-9]{20,}\b", "<REDACTED_STRIPE_SECRET_KEY>"),
        (r"\brk_live_[A-Za-z0-9]{20,}\b", "<REDACTED_STRIPE_RESTRICTED_KEY>"),
    ]
    for pat, repl in patterns:
        text = re.sub(pat, repl, text)

    # Redact env-style secrets: KEY=VALUE (only in added/removed lines to limit false positives)
    text = re.sub(
        r"(?m)^([+-]\s*)([A-Za-z_][A-Za-z0-9_]*(?:PASS|PASSWORD|SECRET|TOKEN|API_KEY|KEY)[A-Za-z0-9_]*)=(.+)$",
        r"\1\2=<REDACTED>",
        text,
        flags=re.IGNORECASE,
    )

    # Redact JSON/YAML-ish "password": "value"
    text = re.sub(
        r'(?i)("?(?:password|passwd|secret|token|api[_-]?key)"?\s*[:=]\s*)(".*?"|\'.*?\'|\S+)',
        r"\1<REDACTED>",
        text,
    )

    # Redact Authorization: Bearer ...
    text = re.sub(
        r"(?i)(Authorization:\s*Bearer\s+)([A-Za-z0-9\-\._~\+/]+=*)",
        r"\1<REDACTED>",
        text,
    )

    return text


def get_patch(repo_root: str, mode: str, path: str) -> str:
    # -M -C for rename/copy detection
    base = ["diff", "-M", "-C", "--no-ext-diff", "--patch", "--unified=3", "--no-color"]
    if mode == "staged":
        base.insert(1, "--cached")
    base += ["--", path]
    out, _ = git(repo_root, base)
    return out


def get_untracked_patch(repo_root: str, path: str) -> str:
    out, _ = git(repo_root, ["diff", "--no-index", "--no-color", "--", "/dev/null", path])
    return out


def main() -> int:
    ap = argparse.ArgumentParser(add_help=True)
    ap.add_argument("-v", "--verbose", action="store_true", help="Show progress on stderr")
    ap.add_argument("--staged", action="store_true", help="Use staged changes only")
    ap.add_argument("--worktree", action="store_true", help="Use working-tree changes (incl. untracked)")
    ap.add_argument("--model", default=None, help="Override Codex model (otherwise use CLI config)")
    ap.add_argument(
        "-c",
        "--config",
        action="append",
        default=[],
        help='Pass through Codex config overrides (repeatable), e.g. -c model_reasoning_effort="medium"',
    )
    ap.add_argument("--max-chars", type=int, default=200_000, help="Max characters sent to Codex")
    ap.add_argument("--max-files", type=int, default=25, help="Max files to include full patches for")
    ap.add_argument("--no-default-excludes", action="store_true", help="Do not exclude lockfiles by default")
    ap.add_argument("--exclude", action="append", default=[], help="Additional exclude glob (repeatable)")
    ap.add_argument("--no-redact", action="store_true", help="Disable secret redaction (not recommended)")
    ap.add_argument("--no-sensitive-skip", action="store_true", help="Include patches for sensitive files too")
    ap.add_argument("files", nargs="*", help="Optional file paths / globs / directories to limit the diff")
    args = ap.parse_args()

    def progress(msg: str) -> None:
        if args.verbose:
            sys.stderr.write(f"[codex-commit] {msg}\n")
            sys.stderr.flush()

    if args.staged and args.worktree:
        sys.stderr.write("Choose only one: --staged or --worktree\n")
        return 2

    # Repo root
    p = run(["git", "rev-parse", "--show-toplevel"], check=False)
    if p.returncode != 0:
        sys.stderr.write("Not a git repository.\n")
        return 2
    repo_root = p.stdout.strip()
    repo_root_p = Path(repo_root)

    specs = normalize_pathspecs(repo_root_p, args.files)

    # Mode selection (auto): staged if there are staged changes for the selected specs; else worktree.
    if args.staged:
        mode = "staged"
    elif args.worktree:
        mode = "worktree"
    else:
        mode = "staged" if has_staged_diff(repo_root, specs) else "worktree"

    # Branch + status
    branch = (git(repo_root, ["rev-parse", "--abbrev-ref", "HEAD"])[0].strip() or "HEAD")
    status_text, _ = git(repo_root, ["status", "--porcelain=v1", "-b"])

    # Build exclude globs
    exclude_globs: list[str] = []
    if not args.no_default_excludes:
        exclude_globs.extend(DEFAULT_EXCLUDE_GLOBS)
    exclude_globs.extend(args.exclude)

    sensitive_globs = [] if args.no_sensitive_skip else list(DEFAULT_SENSITIVE_GLOBS)

    progress(f"mode={mode} specs={specs or '(all)'}")

    # Tracked changed files
    diff_base = ["diff", "-M", "-C", "--name-only"]
    if mode == "staged":
        diff_base.insert(1, "--cached")
    if specs:
        diff_base += ["--", *specs]
    name_only, _ = git(repo_root, diff_base)
    tracked_files_all = [ln.strip() for ln in name_only.splitlines() if ln.strip()]

    # Numstat for ranking
    numstat_args = ["diff", "-M", "-C", "--numstat"]
    if mode == "staged":
        numstat_args.insert(1, "--cached")
    if specs:
        numstat_args += ["--", *specs]
    numstat_text, _ = git(repo_root, numstat_args)
    num_map = parse_numstat(numstat_text)

    # Untracked (worktree mode only)
    untracked_files_all: list[str] = []
    if mode == "worktree":
        untracked_files_all = filter_untracked_by_specs(repo_root, specs)

    # Classify excludes and sensitive
    def classify(paths: list[str]) -> tuple[list[str], list[str], list[str]]:
        kept, excluded, sensitive = [], [], []
        for f in paths:
            if sensitive_globs and matches_any_glob(f, sensitive_globs):
                sensitive.append(f)
                continue
            if exclude_globs and matches_any_glob(f, exclude_globs):
                excluded.append(f)
                continue
            kept.append(f)
        return kept, excluded, sensitive

    tracked_kept, tracked_excluded, tracked_sensitive = classify(tracked_files_all)
    untracked_kept, untracked_excluded, untracked_sensitive = classify(untracked_files_all)

    # If nothing left but we excluded everything, still proceed with a minimal message context.
    if not tracked_kept and not untracked_kept and not tracked_sensitive and not untracked_sensitive:
        sys.stderr.write("codex-commit: no changes found (or everything excluded).\n")
        return 1

    # Build FileChange list for ranking
    changes: list[FileChange] = []
    for f in tracked_kept:
        a, d = num_map.get(f, (None, None))
        score = (a or 0) + (d or 0)
        if score == 0:
            # fallback: small positive score so it can still be included
            score = 1
        changes.append(FileChange(path=f, kind="tracked", added=a, deleted=d, score=score))

    for f in untracked_kept:
        # Score untracked by file size (roughly); cap at something sane
        try:
            size = (repo_root_p / f).stat().st_size
        except Exception:
            size = 0
        score = max(1, min(20000, size // 200))  # heuristic
        changes.append(FileChange(path=f, kind="untracked", added=None, deleted=None, score=score))

    changes.sort(key=lambda c: (c.score, c.path), reverse=True)

    # Summaries
    def fmt_num(n: int | None) -> str:
        return "-" if n is None else str(n)

    summary_lines = []
    for c in changes[:200]:
        summary_lines.append(f"{fmt_num(c.added)}\t{fmt_num(c.deleted)}\t{c.kind}\t{c.path}")

    if tracked_excluded or untracked_excluded:
        ex_list = sorted(set(tracked_excluded + untracked_excluded))
    else:
        ex_list = []

    sens_list = sorted(set(tracked_sensitive + untracked_sensitive))

    header = textwrap.dedent(f"""
    # branch: {branch}
    # mode: {mode}
    # pathspec: {" ".join(specs) if specs else "(all)"}

    # git status (porcelain)
    {status_text.strip()}

    # changed files (added\tdeleted\tkind\tpath)
    {("\n".join(summary_lines) if summary_lines else "(none)")}

    # excluded by default/--exclude (noise)
    {("\n".join(ex_list) if ex_list else "(none)")}

    # sensitive files omitted from patch content
    {("\n".join(sens_list) if sens_list else "(none)")}
    """).strip() + "\n"

    # Build payload with size robustness:
    # include header + patches for top files until budget reached.
    budget = args.max_chars
    payload_parts: list[str] = [header]
    used = len(header)

    omitted_due_to_budget: list[str] = []
    included_files: list[str] = []

    # We'll include at most args.max_files patches.
    for c in changes:
        if len(included_files) >= args.max_files:
            omitted_due_to_budget.append(c.path)
            continue

        if used >= budget:
            omitted_due_to_budget.append(c.path)
            continue

        if c.kind == "tracked":
            patch = get_patch(repo_root, mode, c.path)
        else:
            patch = get_untracked_patch(repo_root, c.path)

        if not patch.strip():
            continue

        if not args.no_redact:
            patch = redact_secrets(patch)

        # Add a small separator (comment) so the model can see which file a patch belongs to.
        block = f"\n# --- PATCH: {c.path} ({c.kind}) ---\n{patch.strip()}\n"
        if used + len(block) <= budget:
            payload_parts.append(block)
            used += len(block)
            included_files.append(c.path)
        else:
            # If we have not included any patches yet, include a truncated block
            if not included_files:
                remaining = max(0, budget - used)
                if remaining > 2000:
                    truncated = block[:remaining] + "\n\n# [...patch truncated to fit budget...]\n"
                    payload_parts.append(truncated)
                    used = budget
                    included_files.append(c.path)
                else:
                    omitted_due_to_budget.append(c.path)
            else:
                omitted_due_to_budget.append(c.path)

    if omitted_due_to_budget:
        tail = "\n# omitted patches due to size/file limit\n" + "\n".join(omitted_due_to_budget) + "\n"
        if used + len(tail) <= budget:
            payload_parts.append(tail)
            used += len(tail)

    payload = "".join(payload_parts)
    if len(payload) > budget:
        payload = payload[:budget] + "\n# [...payload truncated hard cap...]\n"

    # Run Codex (read-only)
    try:
        codex_bin = find_codex_bin()
    except FileNotFoundError as e:
        sys.stderr.write(str(e) + "\n")
        return 127

    schema = {
        "type": "object",
        "properties": {
            "message": {"type": "string"},
        },
        "required": ["message"],
        "additionalProperties": False,
    }

    with tempfile.TemporaryDirectory(dir=repo_root, prefix=".codex-commit-") as td:
        td_p = Path(td)
        diff_path = td_p / "diff.txt"
        schema_path = td_p / "schema.json"
        diff_path.write_text(payload, encoding="utf-8", errors="replace")
        schema_path.write_text(json.dumps(schema, indent=2), encoding="utf-8")

        prompt = textwrap.dedent(f"""
        You are generating a single Git commit message based STRICTLY on the provided diff file.
        Do not invent changes not present.

        Follow these instructions exactly:
        {INSTRUCTION}

        Output requirements (MANDATORY):
        - Respond with valid JSON matching the schema file.
        - JSON must be exactly: {{"message":"..."}}
        - The "message" value must contain ONLY the commit message text.

        Context:
        - Branch: {branch}
        - Mode: {mode}
        - Pathspec: {" ".join(specs) if specs else "(all)"}
        - Some files may be excluded (noise) or have patches omitted due to size.
        - Sensitive files may be listed but their patch content is omitted.

        Read this diff file from disk: {diff_path.relative_to(repo_root_p).as_posix()}
        """).strip()

        cmd = [codex_bin, "exec", "--sandbox", "read-only", "--color", "never"]
        if args.model:
            cmd += ["--model", args.model]
        for c in args.config:
            cmd += ["-c", c]
        cmd += ["--output-schema", str(schema_path), prompt]

        proc = run(cmd, cwd=repo_root, check=False)
        if proc.returncode != 0:
            sys.stderr.write(proc.stderr or "")
            if proc.stdout.strip():
                sys.stderr.write(proc.stdout)
            return proc.returncode

        out = proc.stdout.strip()
        if out.startswith("```"):
            out = out.strip().strip("`").strip()

        try:
            obj = json.loads(out)
        except json.JSONDecodeError:
            sys.stderr.write("Codex did not return valid JSON.\n")
            sys.stderr.write(out + "\n")
            return 3

        msg = (obj.get("message") or "").rstrip("\n")
        if not msg.strip():
            sys.stderr.write("Codex returned an empty message.\n")
            return 3

        # Print ONLY the final message
        sys.stdout.write(msg + "\n")
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
